using AttackAgent.Models;
using Serilog;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Net;

namespace AttackAgent.Engines
{
    /// <summary>
    /// Expert-level vulnerability detection with baseline comparison and advanced techniques
    /// Implements differential analysis, response fingerprinting, and context-aware detection
    /// </summary>
    public class ImprovedVulnerabilityDetection
    {
        private readonly SecurityHttpClient _httpClient;
        private readonly ILogger _logger;
        private readonly Dictionary<string, ResponseBaseline> _baselines = new();

        public ImprovedVulnerabilityDetection(string baseUrl = "")
        {
            _httpClient = new SecurityHttpClient(baseUrl);
            _logger = Log.ForContext<ImprovedVulnerabilityDetection>();
        }

        /// <summary>
        /// Captures baseline response for differential analysis
        /// </summary>
        public async Task<ResponseBaseline> CaptureBaselineAsync(string endpoint, string method = "GET")
        {
            var key = $"{method}:{endpoint}";
            
            if (_baselines.ContainsKey(key))
                return _baselines[key];

            try
            {
                var response = method.ToUpper() == "GET" 
                    ? await _httpClient.GetAsync(endpoint)
                    : await _httpClient.PostAsync(endpoint, null);

                var baseline = new ResponseBaseline
                {
                    Endpoint = endpoint,
                    Method = method,
                    StatusCode = response.StatusCode,
                    Content = response.Content,
                    ContentLength = response.Content?.Length ?? 0,
                    ResponseTime = response.ResponseTime,
                    Headers = response.Headers,
                    ContentHash = ComputeHash(response.Content ?? "")
                };

                _baselines[key] = baseline;
                _logger.Debug("Captured baseline for {Method} {Endpoint}: {StatusCode}, {Length} bytes, {Time}ms",
                    method, endpoint, response.StatusCode, baseline.ContentLength, response.ResponseTime.TotalMilliseconds);

                return baseline;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "Error capturing baseline for {Endpoint}", endpoint);
                return new ResponseBaseline { Endpoint = endpoint, Method = method };
            }
        }

        /// <summary>
        /// Expert-level SQL injection detection with behavioral analysis (works in production)
        /// </summary>
        public async Task<ImprovedSqlInjectionResult> TestSqlInjectionWithBaselineAsync(
            string endpoint, string parameter, string payload, ResponseBaseline baseline)
        {
            var result = new ImprovedSqlInjectionResult { Payload = payload };
            var stopwatch = Stopwatch.StartNew();

            try
            {
                // Build test URL with payload
                var testUrl = $"{endpoint}?{parameter}={Uri.EscapeDataString(payload)}";
                var response = await _httpClient.GetAsync(testUrl);
                stopwatch.Stop();

                result.StatusCode = (int)response.StatusCode;
                result.Response = response.Content ?? "";
                result.ResponseTime = stopwatch.Elapsed;

                // BEHAVIORAL ANALYSIS: Compare with baseline (no error messages needed)
                var contentChanged = response.Content != baseline.Content;
                var lengthDifference = Math.Abs((response.Content?.Length ?? 0) - baseline.ContentLength);
                var lengthChanged = lengthDifference > 50; // Significant change threshold
                var timeChanged = Math.Abs(response.ResponseTime.TotalMilliseconds - baseline.ResponseTime.TotalMilliseconds) > 200;
                var statusCodeChanged = response.StatusCode != (HttpStatusCode)baseline.StatusCode;

                // TIME-BASED BLIND SQL INJECTION DETECTION
                var timeBasedDelay = response.ResponseTime.TotalMilliseconds > 
                    (baseline.ResponseTime.TotalMilliseconds + 3000); // 3 second delay

                // BOOLEAN-BASED BLIND SQL INJECTION DETECTION
                // Check for payloads that cause true/false conditions
                var booleanBasedIndicators = new[]
                {
                    "OR '1'='1", "OR 1=1", "AND 1=1", "OR TRUE", "OR 1=1--"
                };
                var hasBooleanPayload = booleanBasedIndicators.Any(ind => payload.Contains(ind, StringComparison.OrdinalIgnoreCase));
                
                // If boolean payload, check for response differences
                var booleanBasedDetection = hasBooleanPayload && (lengthChanged || statusCodeChanged || contentChanged);

                // UNION-BASED SQL INJECTION DETECTION
                var hasUnionPayload = payload.Contains("UNION", StringComparison.OrdinalIgnoreCase);
                var unionBasedDetection = false;
                if (hasUnionPayload)
                {
                    // UNION injection typically changes response length significantly
                    unionBasedDetection = lengthDifference > 100 || contentChanged;
                }

                // ERROR-BASED SQL INJECTION (fallback, but still useful)
                var errorBasedDetection = false;
                var sqlErrorPatterns = new[]
                {
                    @"SQL syntax", @"mysql_fetch", @"ORA-\d+", @"Microsoft OLE DB",
                    @"ODBC SQL Server Driver", @"PostgreSQL query failed",
                    @"Warning: mysql_", @"valid MySQL result", @"MySqlClient",
                    @"SQLite error", @"SQLiteException", @"SQLSTATE",
                    @"Incorrect syntax", @"Invalid column name", @"Invalid object name"
                };
                errorBasedDetection = sqlErrorPatterns.Any(pattern => 
                    Regex.IsMatch(response.Content ?? "", pattern, RegexOptions.IgnoreCase));

                // STATISTICAL ANALYSIS: Check for anomalies
                var responseLengthRatio = baseline.ContentLength > 0 
                    ? (double)(response.Content?.Length ?? 0) / baseline.ContentLength 
                    : 1.0;
                var responseTimeRatio = baseline.ResponseTime.TotalMilliseconds > 0
                    ? response.ResponseTime.TotalMilliseconds / baseline.ResponseTime.TotalMilliseconds
                    : 1.0;

                // Anomaly detection: significant deviation from baseline
                var lengthAnomaly = responseLengthRatio < 0.5 || responseLengthRatio > 2.0; // 50% decrease or 100% increase
                var timeAnomaly = responseTimeRatio > 2.0; // 2x slower

                // VALIDATION: Require multiple indicators for high confidence
                var indicators = 0;
                if (errorBasedDetection) indicators += 3; // Strong indicator
                if (timeBasedDelay) indicators += 2; // Strong indicator
                if (booleanBasedDetection) indicators += 2;
                if (unionBasedDetection) indicators += 2;
                if (lengthAnomaly) indicators += 1;
                if (timeAnomaly) indicators += 1;
                if (statusCodeChanged) indicators += 1;

                // Require at least 2 indicators for vulnerability (reduces false positives)
                result.IsVulnerable = indicators >= 2;

                // CONFIDENCE SCORING
                if (result.IsVulnerable)
                {
                    result.Confidence = CalculateSqlInjectionConfidence(
                        errorBasedDetection, timeBasedDelay, booleanBasedDetection,
                        unionBasedDetection, lengthAnomaly, timeAnomaly, statusCodeChanged);
                }

                if (result.IsVulnerable)
                {
                    _logger.Warning("ðŸ”´ SQL Injection detected: {Endpoint}?{Param}={Payload} " +
                        "(Confidence: {Confidence:P0}, Indicators: {Indicators}, Time: {Time}ms, Length: {LengthDiff})",
                        endpoint, parameter, payload, result.Confidence, indicators,
                        result.ResponseTime.TotalMilliseconds, lengthDifference);
                }
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
                _logger.Debug("SQL injection test error: {Error}", ex.Message);
            }

            return result;
        }

        /// <summary>
        /// Calculate confidence score for SQL injection detection
        /// </summary>
        private double CalculateSqlInjectionConfidence(
            bool errorBased, bool timeBased, bool booleanBased, bool unionBased,
            bool lengthAnomaly, bool timeAnomaly, bool statusCodeChanged)
        {
            double confidence = 0.0;

            // Error-based detection is highest confidence
            if (errorBased) confidence += 0.4;

            // Time-based detection is very reliable
            if (timeBased) confidence += 0.35;

            // Union-based detection is reliable
            if (unionBased) confidence += 0.3;

            // Boolean-based detection is moderate
            if (booleanBased) confidence += 0.25;

            // Statistical anomalies add confidence
            if (lengthAnomaly) confidence += 0.15;
            if (timeAnomaly) confidence += 0.15;
            if (statusCodeChanged) confidence += 0.1;

            // Cap at 1.0
            return Math.Min(1.0, confidence);
        }

        /// <summary>
        /// Expert-level command injection detection with differential analysis
        /// </summary>
        public async Task<ImprovedCommandInjectionResult> TestCommandInjectionWithBaselineAsync(
            string endpoint, string parameter, string payload, ResponseBaseline baseline)
        {
            var result = new ImprovedCommandInjectionResult { Payload = payload };
            var stopwatch = Stopwatch.StartNew();

            try
            {
                // Build test URL with payload
                var testUrl = $"{endpoint}?{parameter}={Uri.EscapeDataString(payload)}";
                var response = await _httpClient.GetAsync(testUrl);
                stopwatch.Stop();

                result.StatusCode = (int)response.StatusCode;
                result.Response = response.Content ?? "";
                result.ResponseTime = stopwatch.Elapsed;

                // Differential analysis
                var contentChanged = response.Content != baseline.Content;
                var lengthChanged = Math.Abs((response.Content?.Length ?? 0) - baseline.ContentLength) > 10;
                var timeChanged = Math.Abs(response.ResponseTime.TotalMilliseconds - baseline.ResponseTime.TotalMilliseconds) > 100;

                // Advanced detection patterns
                var commandExecutionPatterns = new[]
                {
                    // Unix command output patterns
                    new Regex(@"\b\d+\s+\d+\s+\d+\s+\d+\s+", RegexOptions.IgnoreCase), // ls -l output
                    new Regex(@"^total\s+\d+$", RegexOptions.Multiline | RegexOptions.IgnoreCase), // ls output
                    new Regex(@"^[drwx-]+\s+\d+\s+\w+\s+\w+\s+\d+\s+", RegexOptions.Multiline), // ls -la format
                    new Regex(@"^uid=\d+\([^)]+\)\s+gid=\d+", RegexOptions.Multiline | RegexOptions.IgnoreCase), // id command
                    new Regex(@"^[^:]+:\w+:\d+:\d+:", RegexOptions.Multiline), // /etc/passwd format
                    
                    // Windows command output patterns
                    new Regex(@"^Volume\s+in\s+drive\s+", RegexOptions.Multiline | RegexOptions.IgnoreCase),
                    new Regex(@"^Directory\s+of\s+", RegexOptions.Multiline | RegexOptions.IgnoreCase),
                    new Regex(@"^\d{2}/\d{2}/\d{4}\s+\d{2}:\d{2}\s+(AM|PM)\s+", RegexOptions.Multiline),
                };

                var hasCommandOutput = commandExecutionPatterns.Any(pattern => 
                    pattern.IsMatch(response.Content ?? ""));

                // Check for payload reflection in command context
                var payloadInCommandContext = false;
                if (!string.IsNullOrEmpty(payload))
                {
                    // Check if payload appears in suspicious contexts
                    var payloadIndex = response.Content?.IndexOf(payload, StringComparison.OrdinalIgnoreCase) ?? -1;
                    if (payloadIndex >= 0)
                    {
                        var context = response.Content.Substring(
                            Math.Max(0, payloadIndex - 50), 
                            Math.Min(100, response.Content.Length - payloadIndex));
                        payloadInCommandContext = context.Contains("uid=") || 
                                                  context.Contains("gid=") || 
                                                  context.Contains("total ") ||
                                                  context.Contains("Directory");
                    }
                }

                // Time-based detection for blind command injection
                var timeBasedDetection = response.ResponseTime.TotalMilliseconds > 
                    (baseline.ResponseTime.TotalMilliseconds + 2000); // 2 second delay

                // Validation: Must have multiple indicators
                result.IsVulnerable = (hasCommandOutput || payloadInCommandContext) && 
                                     (contentChanged || lengthChanged || timeChanged) &&
                                     !IsFalsePositive(response.Content ?? "", baseline.Content);

                // Confidence scoring
                if (result.IsVulnerable)
                {
                    result.Confidence = CalculateCommandInjectionConfidence(
                        hasCommandOutput, payloadInCommandContext, timeBasedDetection, 
                        contentChanged, lengthChanged, timeChanged);
                }

                if (result.IsVulnerable)
                {
                    _logger.Warning("ðŸ”´ Command Injection detected: {Endpoint}?{Param}={Payload} " +
                        "(Confidence: {Confidence:P0}, Time: {Time}ms, Changed: {Changed})",
                        endpoint, parameter, payload, result.Confidence, 
                        result.ResponseTime.TotalMilliseconds, contentChanged || lengthChanged);
                }
            }
            catch (Exception ex)
            {
                result.Error = ex.Message;
                _logger.Debug("Command injection test error: {Error}", ex.Message);
            }

            return result;
        }

        /// <summary>
        /// Filters false positives by checking against baseline
        /// </summary>
        private bool IsFalsePositive(string testResponse, string baselineResponse)
        {
            // If baseline already contains command indicators, likely false positive
            var falsePositivePatterns = new[]
            {
                new Regex(@"\broot\b", RegexOptions.IgnoreCase),
                new Regex(@"\badministrator\b", RegexOptions.IgnoreCase),
            };

            // Check if baseline has these patterns (meaning they're part of normal content)
            foreach (var pattern in falsePositivePatterns)
            {
                if (pattern.IsMatch(baselineResponse) && pattern.IsMatch(testResponse))
                {
                    // Both have it, likely false positive
                    return true;
                }
            }

            // Check for common false positive contexts
            var falsePositiveContexts = new[]
            {
                ":root",           // CSS :root selector
                "rootElement",     // JavaScript
                "rootElement",    // DOM API
                "document.root",   // DOM API
                "administrator",   // In HTML/CSS (not command output)
            };

            foreach (var context in falsePositiveContexts)
            {
                if (baselineResponse.Contains(context, StringComparison.OrdinalIgnoreCase) &&
                    testResponse.Contains(context, StringComparison.OrdinalIgnoreCase))
                {
                    return true; // Same context, likely false positive
                }
            }

            return false;
        }

        /// <summary>
        /// Calculates confidence score for command injection detection
        /// </summary>
        private double CalculateCommandInjectionConfidence(
            bool hasCommandOutput, bool payloadInContext, bool timeBased,
            bool contentChanged, bool lengthChanged, bool timeChanged)
        {
            double confidence = 0.3; // Base confidence

            if (hasCommandOutput) confidence += 0.4; // Strong indicator
            if (payloadInContext) confidence += 0.2; // Good indicator
            if (timeBased) confidence += 0.15; // Time-based detection
            if (contentChanged) confidence += 0.1; // Response changed
            if (lengthChanged) confidence += 0.05; // Length changed
            if (timeChanged && !timeBased) confidence += 0.05; // Timing anomaly

            return Math.Min(1.0, confidence);
        }

        /// <summary>
        /// Improved credential detection with regex patterns and context validation
        /// </summary>
        public List<CredentialFinding> DetectCredentialsInResponse(string content, string endpoint)
        {
            var findings = new List<CredentialFinding>();

            if (string.IsNullOrEmpty(content))
                return findings;

            // Skip credential detection in CSS/JS contexts
            if (IsInCodeContext(content))
                return findings;

            // Specific credential patterns (high confidence)
            var highConfidencePatterns = new[]
            {
                // OpenAI API Keys
                new CredentialPattern
                {
                    Pattern = new Regex(@"sk-proj-[a-zA-Z0-9_-]{32,}", RegexOptions.IgnoreCase),
                    Type = "OpenAI API Key",
                    Severity = SeverityLevel.Critical,
                    Confidence = 0.95
                },
                // AWS Access Keys
                new CredentialPattern
                {
                    Pattern = new Regex(@"AKIA[0-9A-Z]{16}", RegexOptions.IgnoreCase),
                    Type = "AWS Access Key",
                    Severity = SeverityLevel.Critical,
                    Confidence = 0.95
                },
                // Database connection strings
                new CredentialPattern
                {
                    Pattern = new Regex(@"Server=([^;]+);.*Password=([^;]+)", RegexOptions.IgnoreCase),
                    Type = "Database Connection String",
                    Severity = SeverityLevel.Critical,
                    Confidence = 0.9
                },
                // JWT tokens (basic detection)
                new CredentialPattern
                {
                    Pattern = new Regex(@"eyJ[A-Za-z0-9-_=]+\.eyJ[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*", RegexOptions.IgnoreCase),
                    Type = "JWT Token",
                    Severity = SeverityLevel.High,
                    Confidence = 0.85
                },
            };

            // Medium confidence patterns
            var mediumConfidencePatterns = new[]
            {
                // Generic API keys (must be in specific context)
                new CredentialPattern
                {
                    Pattern = new Regex(@"(?:api[_-]?key|apikey)\s*[=:]\s*([a-zA-Z0-9_-]{20,})", RegexOptions.IgnoreCase),
                    Type = "API Key",
                    Severity = SeverityLevel.High,
                    Confidence = 0.7,
                    RequiresContext = true
                },
                // Database server names (specific patterns)
                new CredentialPattern
                {
                    Pattern = new Regex(@"sql\d+\.site4now\.net", RegexOptions.IgnoreCase),
                    Type = "Database Server Information",
                    Severity = SeverityLevel.Medium,
                    Confidence = 0.6
                },
            };

            // Test high confidence patterns
            foreach (var pattern in highConfidencePatterns)
            {
                var matches = pattern.Pattern.Matches(content);
                foreach (Match match in matches)
                {
                    findings.Add(new CredentialFinding
                    {
                        Type = pattern.Type,
                        Value = match.Value,
                        Severity = pattern.Severity,
                        Confidence = pattern.Confidence,
                        Endpoint = endpoint,
                        LineNumber = GetLineNumber(content, match.Index)
                    });
                }
            }

            // Test medium confidence patterns (only if in appropriate context)
            foreach (var pattern in mediumConfidencePatterns)
            {
                if (pattern.RequiresContext && !IsInCredentialContext(content))
                    continue;

                var matches = pattern.Pattern.Matches(content);
                foreach (Match match in matches)
                {
                    findings.Add(new CredentialFinding
                    {
                        Type = pattern.Type,
                        Value = match.Value,
                        Severity = pattern.Severity,
                        Confidence = pattern.Confidence,
                        Endpoint = endpoint,
                        LineNumber = GetLineNumber(content, match.Index)
                    });
                }
            }

            return findings;
        }

        /// <summary>
        /// Checks if content is in CSS/JS context (should skip credential detection)
        /// </summary>
        private bool IsInCodeContext(string content)
        {
            // Simple heuristic: if content is mostly CSS or JS, skip
            var cssIndicators = new[] { "{", "}", ":", ";", "@media", "@import", ".", "#" };
            var jsIndicators = new[] { "function", "var ", "let ", "const ", "=>", "()" };

            var cssCount = cssIndicators.Count(ind => content.Contains(ind));
            var jsCount = jsIndicators.Count(ind => content.Contains(ind, StringComparison.OrdinalIgnoreCase));

            return cssCount > 5 || jsCount > 5;
        }

        /// <summary>
        /// Checks if content is in a credential-related context
        /// </summary>
        private bool IsInCredentialContext(string content)
        {
            var credentialContexts = new[]
            {
                "ConnectionString", "ApiKey", "Password", "Secret", "Token",
                "Credentials", "Authentication", "Config", "Settings"
            };

            return credentialContexts.Any(ctx => 
                content.Contains(ctx, StringComparison.OrdinalIgnoreCase));
        }

        /// <summary>
        /// Gets line number for a match position
        /// </summary>
        private int GetLineNumber(string content, int position)
        {
            return content.Substring(0, position).Split('\n').Length;
        }

        /// <summary>
        /// Computes simple hash for response comparison
        /// </summary>
        private string ComputeHash(string content)
        {
            using var sha256 = System.Security.Cryptography.SHA256.Create();
            var hash = sha256.ComputeHash(System.Text.Encoding.UTF8.GetBytes(content));
            return Convert.ToBase64String(hash).Substring(0, 16);
        }

        public void Dispose()
        {
            _httpClient?.Dispose();
        }
    }

    /// <summary>
    /// Baseline response for differential analysis
    /// </summary>
    public class ResponseBaseline
    {
        public string Endpoint { get; set; } = "";
        public string Method { get; set; } = "GET";
        public HttpStatusCode StatusCode { get; set; }
        public string Content { get; set; } = "";
        public int ContentLength { get; set; }
        public TimeSpan ResponseTime { get; set; }
        public Dictionary<string, string> Headers { get; set; } = new();
        public string ContentHash { get; set; } = "";
    }

    /// <summary>
    /// Credential pattern for detection
    /// </summary>
    public class CredentialPattern
    {
        public Regex Pattern { get; set; } = null!;
        public string Type { get; set; } = "";
        public SeverityLevel Severity { get; set; }
        public double Confidence { get; set; }
        public bool RequiresContext { get; set; } = false;
    }

    /// <summary>
    /// Credential finding
    /// </summary>
    public class CredentialFinding
    {
        public string Type { get; set; } = "";
        public string Value { get; set; } = "";
        public SeverityLevel Severity { get; set; }
        public double Confidence { get; set; }
        public string Endpoint { get; set; } = "";
        public int LineNumber { get; set; }
    }

    /// <summary>
    /// Enhanced SQL injection result with behavioral analysis
    /// </summary>
    public class ImprovedSqlInjectionResult
    {
        public string Payload { get; set; } = "";
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = "";
        public int StatusCode { get; set; }
        public string? Error { get; set; }
        public TimeSpan ResponseTime { get; set; }
        public double Confidence { get; set; }
    }

    /// <summary>
    /// Enhanced command injection result with confidence scoring
    /// </summary>
    public class ImprovedCommandInjectionResult
    {
        public string Payload { get; set; } = "";
        public bool IsVulnerable { get; set; }
        public string Response { get; set; } = "";
        public int StatusCode { get; set; }
        public string? Error { get; set; }
        public TimeSpan ResponseTime { get; set; }
        public double Confidence { get; set; }
    }
}

