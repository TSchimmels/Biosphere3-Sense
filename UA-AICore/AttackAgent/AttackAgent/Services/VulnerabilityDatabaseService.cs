using AttackAgent.Models;
using Serilog;
using Microsoft.Data.SqlClient;

namespace AttackAgent.Services
{
    /// <summary>
    /// Service for saving AttackAgent vulnerabilities to the WebsiteTest database
    /// Simple implementation using direct SQL for minimal dependencies
    /// </summary>
    public class VulnerabilityDatabaseService
    {
        private readonly string? _connectionString;
        private readonly ILogger _logger;
        private readonly bool _enabled;

        public VulnerabilityDatabaseService(string? connectionString = null)
        {
            _connectionString = connectionString;
            _logger = Log.ForContext<VulnerabilityDatabaseService>();
            _enabled = !string.IsNullOrWhiteSpace(_connectionString);
            
            if (!_enabled)
            {
                _logger.Information("üìä Vulnerability database storage is disabled (no connection string provided)");
            }
            else
            {
                _logger.Information("üìä Vulnerability database storage is enabled");
            }
        }

        /// <summary>
        /// Saves vulnerabilities from a scan to the database
        /// Each vulnerability is saved as its own row (no deduplication)
        /// </summary>
        public async Task SaveVulnerabilitiesAsync(
            string targetUrl,
            List<Vulnerability> vulnerabilities,
            DateTime scanStartTime,
            DateTime scanEndTime,
            string? scanId = null)
        {
            if (!_enabled || vulnerabilities == null || !vulnerabilities.Any())
            {
                return;
            }

            // Generate scan ID if not provided
            var effectiveScanId = scanId ?? Guid.NewGuid().ToString("N")[..12];

            try
            {
                _logger.Information("üíæ Saving {Count} vulnerabilities to database (ScanId: {ScanId})...", vulnerabilities.Count, effectiveScanId);

                using var connection = new SqlConnection(_connectionString);
                await connection.OpenAsync();

                // Ensure table exists and has new columns
                await EnsureTableExistsAsync(connection);

                var insertedCount = 0;

                // INSERT with new columns (ScanId, ApplicationScanned, ScanTime)
                var sql = @"
                    INSERT INTO AttackAgentVulnerabilities 
                    (VulnerabilityType, Severity, Confidence, Endpoint, Method, Parameter, Payload, Evidence, FalsePositive, Verified, ScanId, ApplicationScanned, ScanTime)
                    VALUES 
                    (@VulnerabilityType, @Severity, @Confidence, @Endpoint, @Method, @Parameter, @Payload, @Evidence, @FalsePositive, @Verified, @ScanId, @ApplicationScanned, @ScanTime);";

                foreach (var vuln in vulnerabilities)
                {
                    try
                    {
                        using var command = new SqlCommand(sql, connection);
                        command.Parameters.AddWithValue("@VulnerabilityType", vuln.Type.ToString());
                        command.Parameters.AddWithValue("@Severity", vuln.Severity.ToString());
                        command.Parameters.AddWithValue("@Confidence", (decimal)vuln.Confidence);
                        command.Parameters.AddWithValue("@Endpoint", (object?)vuln.Endpoint ?? DBNull.Value);
                        command.Parameters.AddWithValue("@Method", (object?)vuln.Method ?? DBNull.Value);
                        command.Parameters.AddWithValue("@Parameter", (object?)vuln.Parameter ?? DBNull.Value);
                        command.Parameters.AddWithValue("@Payload", (object?)vuln.Payload ?? DBNull.Value);
                        command.Parameters.AddWithValue("@Evidence", (object?)vuln.Evidence ?? DBNull.Value);
                        command.Parameters.AddWithValue("@FalsePositive", vuln.FalsePositive);
                        command.Parameters.AddWithValue("@Verified", vuln.Verified);
                        command.Parameters.AddWithValue("@ScanId", effectiveScanId);
                        command.Parameters.AddWithValue("@ApplicationScanned", targetUrl);
                        command.Parameters.AddWithValue("@ScanTime", scanStartTime);

                        await command.ExecuteNonQueryAsync();
                        insertedCount++;
                    }
                    catch (Exception ex)
                    {
                        _logger.Warning(ex, "Failed to save vulnerability to database: {Error}", ex.Message);
                        // Continue with next vulnerability
                    }
                }

                _logger.Information("‚úÖ Database save completed: {InsertedCount} vulnerabilities inserted", insertedCount);
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "‚ùå Error saving vulnerabilities to database");
                // Don't throw - we don't want database errors to break the scan
            }
        }

        /// <summary>
        /// Ensures the AttackAgentVulnerabilities table exists with all columns
        /// </summary>
        private async Task EnsureTableExistsAsync(SqlConnection connection)
        {
            try
            {
                // First, check if table exists
                var checkTableSql = @"
                    SELECT COUNT(*) 
                    FROM sys.objects 
                    WHERE object_id = OBJECT_ID(N'[dbo].[AttackAgentVulnerabilities]') 
                    AND type in (N'U')";

                using var checkCommand = new SqlCommand(checkTableSql, connection);
                var tableExists = (int)await checkCommand.ExecuteScalarAsync() > 0;

                if (!tableExists)
                {
                    _logger.Information("üìã Creating AttackAgentVulnerabilities table...");
                    
                    // Create table with all columns including new ones
                    var createTableSql = @"
                        CREATE TABLE [dbo].[AttackAgentVulnerabilities] (
                            [Id] INT IDENTITY(1,1) PRIMARY KEY,
                            [VulnerabilityType] NVARCHAR(50) NOT NULL,
                            [Severity] NVARCHAR(20) NOT NULL,
                            [Confidence] DECIMAL(5,2) NOT NULL,
                            [Endpoint] NVARCHAR(500) NULL,
                            [Method] NVARCHAR(10) NULL,
                            [Parameter] NVARCHAR(200) NULL,
                            [Payload] NVARCHAR(2000) NULL,
                            [Evidence] NVARCHAR(MAX) NULL,
                            [FalsePositive] BIT NOT NULL DEFAULT 0,
                            [Verified] BIT NOT NULL DEFAULT 0,
                            [ScanId] NVARCHAR(50) NULL,
                            [ApplicationScanned] NVARCHAR(500) NULL,
                            [ScanTime] DATETIME2 NULL
                        );";

                    using var createCommand = new SqlCommand(createTableSql, connection);
                    await createCommand.ExecuteNonQueryAsync();
                    _logger.Information("‚úÖ Table created successfully");

                    await CreateIndexesAsync(connection);
                }
                else
                {
                    _logger.Information("‚úÖ AttackAgentVulnerabilities table already exists");
                    
                    // Check if new columns exist and add them if not
                    await AddMissingColumnsAsync(connection);
                }

                // Verify table exists now
                var verifyExists = (int)await checkCommand.ExecuteScalarAsync() > 0;
                if (!verifyExists)
                {
                    throw new InvalidOperationException("Table creation failed - table does not exist after creation attempt");
                }
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "‚ùå Failed to ensure AttackAgentVulnerabilities table exists: {Error}", ex.Message);
                throw;
            }
        }

        /// <summary>
        /// Adds missing columns to existing table (for schema migration)
        /// </summary>
        private async Task AddMissingColumnsAsync(SqlConnection connection)
        {
            var columnsToAdd = new[]
            {
                ("ScanId", "NVARCHAR(50) NULL"),
                ("ApplicationScanned", "NVARCHAR(500) NULL"),
                ("ScanTime", "DATETIME2 NULL")
            };

            foreach (var (columnName, columnType) in columnsToAdd)
            {
                try
                {
                    // Check if column exists
                    var checkColumnSql = @"
                        SELECT COUNT(*) FROM sys.columns 
                        WHERE object_id = OBJECT_ID(N'[dbo].[AttackAgentVulnerabilities]') 
                        AND name = @ColumnName";

                    using var checkCmd = new SqlCommand(checkColumnSql, connection);
                    checkCmd.Parameters.AddWithValue("@ColumnName", columnName);
                    var columnExists = (int)await checkCmd.ExecuteScalarAsync() > 0;

                    if (!columnExists)
                    {
                        _logger.Information("üìã Adding column {Column} to table...", columnName);
                        var alterSql = $"ALTER TABLE [dbo].[AttackAgentVulnerabilities] ADD [{columnName}] {columnType}";
                        using var alterCmd = new SqlCommand(alterSql, connection);
                        await alterCmd.ExecuteNonQueryAsync();
                        _logger.Information("‚úÖ Column {Column} added successfully", columnName);
                    }
                }
                catch (Exception ex)
                {
                    _logger.Warning(ex, "‚ö†Ô∏è Could not add column {Column}: {Error}", columnName, ex.Message);
                }
            }

            // Also fix Confidence column precision if needed
            try
            {
                var alterConfidenceSql = "ALTER TABLE [dbo].[AttackAgentVulnerabilities] ALTER COLUMN [Confidence] DECIMAL(5,2) NOT NULL";
                using var alterCmd = new SqlCommand(alterConfidenceSql, connection);
                await alterCmd.ExecuteNonQueryAsync();
            }
            catch
            {
                // Column might already be correct type
            }
        }

        /// <summary>
        /// Creates indexes on the table
        /// </summary>
        private async Task CreateIndexesAsync(SqlConnection connection)
        {
            var indexes = new[]
            {
                "CREATE NONCLUSTERED INDEX IX_AttackAgentVulnerabilities_VulnerabilityType ON [dbo].[AttackAgentVulnerabilities]([VulnerabilityType]);",
                "CREATE NONCLUSTERED INDEX IX_AttackAgentVulnerabilities_Severity ON [dbo].[AttackAgentVulnerabilities]([Severity]);",
                "CREATE NONCLUSTERED INDEX IX_AttackAgentVulnerabilities_FalsePositive ON [dbo].[AttackAgentVulnerabilities]([FalsePositive]);",
                "CREATE NONCLUSTERED INDEX IX_AttackAgentVulnerabilities_Verified ON [dbo].[AttackAgentVulnerabilities]([Verified]);",
                "CREATE NONCLUSTERED INDEX IX_AttackAgentVulnerabilities_ScanId ON [dbo].[AttackAgentVulnerabilities]([ScanId]);",
                "CREATE NONCLUSTERED INDEX IX_AttackAgentVulnerabilities_ApplicationScanned ON [dbo].[AttackAgentVulnerabilities]([ApplicationScanned]);"
            };

            foreach (var indexSql in indexes)
            {
                try
                {
                    using var indexCommand = new SqlCommand(indexSql, connection);
                    await indexCommand.ExecuteNonQueryAsync();
                }
                catch (Exception idxEx)
                {
                    // Index might already exist, that's okay
                    _logger.Debug("Index creation note: {Message}", idxEx.Message);
                }
            }

            _logger.Information("‚úÖ Indexes created successfully");
        }

        /// <summary>
        /// Marks DenialOfService vulnerabilities on theoretical endpoints as false positives
        /// </summary>
        public async Task<int> MarkDosFalsePositivesAsync()
        {
            if (!_enabled) return 0;

            try
            {
                using var connection = new SqlConnection(_connectionString);
                await connection.OpenAsync();

                // Mark DoS vulnerabilities with generic "Resource-intensive endpoint without rate limiting" as false positives
                var sql = @"
                    UPDATE AttackAgentVulnerabilities 
                    SET FalsePositive = 1, Verified = 0
                    WHERE VulnerabilityType = 'DenialOfService' 
                    AND Evidence LIKE '%Resource-intensive endpoint without rate limiting%'
                    AND FalsePositive = 0";

                using var command = new SqlCommand(sql, connection);
                var rowsAffected = await command.ExecuteNonQueryAsync();
                
                _logger.Information("‚úÖ Marked {Count} DoS false positives", rowsAffected);
                return rowsAffected;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "‚ùå Error marking DoS false positives");
                return 0;
            }
        }

        /// <summary>
        /// Deletes duplicate vulnerabilities, keeping only one per endpoint/parameter/type combination
        /// </summary>
        public async Task<int> DeleteDuplicateVulnerabilitiesAsync()
        {
            if (!_enabled) return 0;

            try
            {
                using var connection = new SqlConnection(_connectionString);
                await connection.OpenAsync();

                // Delete duplicates keeping the one with highest confidence (or lowest ID if same confidence)
                var sql = @"
                    WITH CTE AS (
                        SELECT Id,
                            ROW_NUMBER() OVER (
                                PARTITION BY VulnerabilityType, Endpoint, Parameter, Method
                                ORDER BY Confidence DESC, Id ASC
                            ) AS RowNum
                        FROM AttackAgentVulnerabilities
                        WHERE VulnerabilityType IN ('ReflectedXss', 'StoredXss', 'SqlInjection')
                    )
                    DELETE FROM CTE WHERE RowNum > 1";

                using var command = new SqlCommand(sql, connection);
                command.CommandTimeout = 120; // 2 minute timeout for large deletions
                var rowsAffected = await command.ExecuteNonQueryAsync();
                
                _logger.Information("‚úÖ Deleted {Count} duplicate vulnerabilities", rowsAffected);
                return rowsAffected;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "‚ùå Error deleting duplicate vulnerabilities");
                return 0;
            }
        }

        /// <summary>
        /// Performs full database cleanup: marks false positives and removes duplicates
        /// </summary>
        public async Task<(int falsePositivesMarked, int duplicatesDeleted)> CleanupDatabaseAsync()
        {
            _logger.Information("üßπ Starting database cleanup...");
            
            var falsePositives = await MarkDosFalsePositivesAsync();
            var duplicates = await DeleteDuplicateVulnerabilitiesAsync();
            
            _logger.Information("‚úÖ Database cleanup completed: {FP} false positives marked, {Dup} duplicates deleted", 
                falsePositives, duplicates);
            
            return (falsePositives, duplicates);
        }

        /// <summary>
        /// Gets statistics about vulnerabilities in the database
        /// </summary>
        public async Task<DatabaseCleanupStats> GetDatabaseStatsAsync()
        {
            if (!_enabled) return new DatabaseCleanupStats();

            try
            {
                using var connection = new SqlConnection(_connectionString);
                await connection.OpenAsync();

                var stats = new DatabaseCleanupStats();

                // Total count
                using (var cmd = new SqlCommand("SELECT COUNT(*) FROM AttackAgentVulnerabilities", connection))
                {
                    stats.TotalCount = (int)await cmd.ExecuteScalarAsync();
                }

                // False positives count
                using (var cmd = new SqlCommand("SELECT COUNT(*) FROM AttackAgentVulnerabilities WHERE FalsePositive = 1", connection))
                {
                    stats.FalsePositiveCount = (int)await cmd.ExecuteScalarAsync();
                }

                // Verified count
                using (var cmd = new SqlCommand("SELECT COUNT(*) FROM AttackAgentVulnerabilities WHERE Verified = 1", connection))
                {
                    stats.VerifiedCount = (int)await cmd.ExecuteScalarAsync();
                }

                // DoS count (potential false positives)
                using (var cmd = new SqlCommand(@"
                    SELECT COUNT(*) FROM AttackAgentVulnerabilities 
                    WHERE VulnerabilityType = 'DenialOfService' 
                    AND Evidence LIKE '%Resource-intensive endpoint without rate limiting%'
                    AND FalsePositive = 0", connection))
                {
                    stats.PotentialDosFalsePositives = (int)await cmd.ExecuteScalarAsync();
                }

                // Duplicate XSS count
                using (var cmd = new SqlCommand(@"
                    SELECT COUNT(*) - COUNT(DISTINCT CONCAT(VulnerabilityType, '|', Endpoint, '|', Parameter, '|', Method))
                    FROM AttackAgentVulnerabilities 
                    WHERE VulnerabilityType IN ('ReflectedXss', 'StoredXss', 'SqlInjection')", connection))
                {
                    stats.PotentialDuplicates = (int)await cmd.ExecuteScalarAsync();
                }

                return stats;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "‚ùå Error getting database stats");
                return new DatabaseCleanupStats();
            }
        }

        /// <summary>
        /// Tests the database connection
        /// </summary>
        public async Task<bool> TestConnectionAsync()
        {
            if (!_enabled)
            {
                return false;
            }

            try
            {
                using var connection = new SqlConnection(_connectionString);
                await connection.OpenAsync();
                _logger.Information("‚úÖ Database connection test successful");
                return true;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "‚ùå Database connection test failed");
                return false;
            }
        }

        /// <summary>
        /// Tests database setup: creates table, inserts test record, verifies, then cleans up
        /// </summary>
        public async Task<bool> TestDatabaseSetupAsync()
        {
            if (!_enabled)
            {
                _logger.Warning("‚ö†Ô∏è  Database storage is disabled, skipping setup test");
                return false;
            }

            try
            {
                _logger.Information("üß™ Testing database setup...");
                
                using var connection = new SqlConnection(_connectionString);
                await connection.OpenAsync();

                // Step 1: Ensure table exists
                _logger.Information("üìã Step 1: Creating/verifying table...");
                await EnsureTableExistsAsync(connection);
                _logger.Information("‚úÖ Table verified/created");

                // Step 2: Insert test vulnerability
                _logger.Information("üìù Step 2: Inserting test vulnerability...");

                var insertTestSql = @"
                    INSERT INTO [dbo].[AttackAgentVulnerabilities] 
                    (VulnerabilityType, Severity, Confidence, Endpoint, Method, Parameter, Payload, Evidence, FalsePositive, Verified, ScanId, ApplicationScanned, ScanTime)
                    VALUES 
                    (@VulnerabilityType, @Severity, @Confidence, @Endpoint, @Method, @Parameter, @Payload, @Evidence, @FalsePositive, @Verified, @ScanId, @ApplicationScanned, @ScanTime);
                    SELECT CAST(SCOPE_IDENTITY() AS INT);";

                using var insertCommand = new SqlCommand(insertTestSql, connection);
                insertCommand.Parameters.AddWithValue("@VulnerabilityType", "TestVulnerability");
                insertCommand.Parameters.AddWithValue("@Severity", "Low");
                insertCommand.Parameters.AddWithValue("@Confidence", (decimal)0.5);
                insertCommand.Parameters.AddWithValue("@Endpoint", "/test/endpoint");
                insertCommand.Parameters.AddWithValue("@Method", "GET");
                insertCommand.Parameters.AddWithValue("@Parameter", "testParam");
                insertCommand.Parameters.AddWithValue("@Payload", "test-payload-123");
                insertCommand.Parameters.AddWithValue("@Evidence", "Test evidence");
                insertCommand.Parameters.AddWithValue("@FalsePositive", false);
                insertCommand.Parameters.AddWithValue("@Verified", false);
                insertCommand.Parameters.AddWithValue("@ScanId", "test-scan-001");
                insertCommand.Parameters.AddWithValue("@ApplicationScanned", "http://test.example.com");
                insertCommand.Parameters.AddWithValue("@ScanTime", DateTime.UtcNow);

                var insertedId = await insertCommand.ExecuteScalarAsync();
                _logger.Information("‚úÖ Test vulnerability inserted with ID: {Id}", insertedId);

                // Step 3: Verify the record exists
                _logger.Information("üîç Step 3: Verifying test record...");
                var verifySql = @"
                    SELECT COUNT(*) 
                    FROM [dbo].[AttackAgentVulnerabilities] 
                    WHERE VulnerabilityType = @VulnerabilityType AND Payload = @Payload";

                using var verifyCommand = new SqlCommand(verifySql, connection);
                verifyCommand.Parameters.AddWithValue("@VulnerabilityType", "TestVulnerability");
                verifyCommand.Parameters.AddWithValue("@Payload", "test-payload-123");

                var count = (int)await verifyCommand.ExecuteScalarAsync();
                if (count == 0)
                {
                    throw new InvalidOperationException("Test record was not found after insertion");
                }
                _logger.Information("‚úÖ Test record verified (found {Count} record(s))", count);

                // Step 4: Clean up test data
                _logger.Information("üßπ Step 4: Cleaning up test data...");
                var cleanupSql = @"
                    DELETE FROM [dbo].[AttackAgentVulnerabilities] 
                    WHERE VulnerabilityType = @VulnerabilityType AND Payload = @Payload";

                using var cleanupCommand = new SqlCommand(cleanupSql, connection);
                cleanupCommand.Parameters.AddWithValue("@VulnerabilityType", "TestVulnerability");
                cleanupCommand.Parameters.AddWithValue("@Payload", "test-payload-123");
                var deletedRows = await cleanupCommand.ExecuteNonQueryAsync();
                _logger.Information("‚úÖ Cleaned up {Count} test record(s)", deletedRows);

                _logger.Information("‚úÖ Database setup test completed successfully!");
                return true;
            }
            catch (Exception ex)
            {
                _logger.Error(ex, "‚ùå Database setup test failed: {Error}", ex.Message);
                return false;
            }
        }
    }

    /// <summary>
    /// Statistics for database cleanup
    /// </summary>
    public class DatabaseCleanupStats
    {
        public int TotalCount { get; set; }
        public int FalsePositiveCount { get; set; }
        public int VerifiedCount { get; set; }
        public int PotentialDosFalsePositives { get; set; }
        public int PotentialDuplicates { get; set; }
    }
}
