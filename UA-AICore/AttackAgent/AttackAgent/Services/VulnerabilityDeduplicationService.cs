using AttackAgent.Models;
using Serilog;
using System.Text.Json;

namespace AttackAgent.Services
{
    /// <summary>
    /// Service for deduplicating vulnerabilities to reduce noise in reports
    /// </summary>
    public class VulnerabilityDeduplicationService
    {
        private readonly ILogger _logger;

        public VulnerabilityDeduplicationService()
        {
            _logger = Log.ForContext<VulnerabilityDeduplicationService>();
        }

        /// <summary>
        /// Deduplicates vulnerabilities based on endpoint, type, and payload similarity
        /// </summary>
        public List<Vulnerability> DeduplicateVulnerabilities(List<Vulnerability> vulnerabilities)
        {
            _logger.Information("üîç Starting vulnerability deduplication process...");
            _logger.Information("üìä Input vulnerabilities: {Count}", vulnerabilities.Count);

            var deduplicatedVulns = new List<Vulnerability>();
            var groupedVulns = GroupVulnerabilitiesBySimilarity(vulnerabilities);

            foreach (var group in groupedVulns)
            {
                var consolidatedVuln = ConsolidateVulnerabilityGroup(group);
                deduplicatedVulns.Add(consolidatedVuln);
            }

            _logger.Information("‚úÖ Deduplication completed: {OriginalCount} ‚Üí {DeduplicatedCount} vulnerabilities", 
                vulnerabilities.Count, deduplicatedVulns.Count);
            _logger.Information("üìâ Reduction: {ReductionPercent:P1}", 
                (double)(vulnerabilities.Count - deduplicatedVulns.Count) / vulnerabilities.Count);

            return deduplicatedVulns;
        }

        /// <summary>
        /// Groups vulnerabilities by similarity (endpoint, type, and payload pattern)
        /// </summary>
        private List<List<Vulnerability>> GroupVulnerabilitiesBySimilarity(List<Vulnerability> vulnerabilities)
        {
            var groups = new List<List<Vulnerability>>();
            var processed = new HashSet<string>();

            foreach (var vuln in vulnerabilities)
            {
                var groupKey = GenerateGroupKey(vuln);
                
                if (processed.Contains(groupKey))
                    continue;

                var similarVulns = vulnerabilities.Where(v => 
                    GenerateGroupKey(v) == groupKey).ToList();
                
                groups.Add(similarVulns);
                processed.Add(groupKey);
            }

            return groups;
        }

        /// <summary>
        /// Generates a grouping key based on endpoint, type, and payload pattern
        /// For XSS vulnerabilities, group ALL on same endpoint together regardless of payload
        /// </summary>
        private string GenerateGroupKey(Vulnerability vuln)
        {
            // For XSS vulnerabilities, group ALL on same endpoint together (ignore payload differences)
            if (vuln.Type == VulnerabilityType.ReflectedXss || 
                vuln.Type == VulnerabilityType.StoredXss || 
                vuln.Type == VulnerabilityType.DomXss)
            {
                // Group all XSS on same endpoint together
                return $"{vuln.Endpoint}|{vuln.Method}|{vuln.Type}|XSS_ALL";
            }
            
            // For other vulnerability types, use payload pattern
            var payloadPattern = NormalizePayload(vuln.Payload ?? "");
            return $"{vuln.Endpoint}|{vuln.Method}|{vuln.Type}|{payloadPattern}";
        }

        /// <summary>
        /// Normalizes payload to extract the attack pattern
        /// </summary>
        private string NormalizePayload(string payload)
        {
            if (string.IsNullOrEmpty(payload))
                return "empty";

            // SQL Injection patterns
            if (payload.Contains("UNION SELECT"))
                return "UNION_SELECT";
            if (payload.Contains("OR '1'='1"))
                return "OR_TRUE";
            if (payload.Contains("OR 1=1"))
                return "OR_1_1";
            if (payload.Contains("DROP TABLE"))
                return "DROP_TABLE";
            if (payload.Contains("WAITFOR DELAY"))
                return "TIME_DELAY";
            if (payload.Contains("SLEEP("))
                return "SLEEP";

            // XSS patterns
            if (payload.Contains("<script>"))
                return "SCRIPT_TAG";
            if (payload.Contains("onerror="))
                return "ONERROR";
            if (payload.Contains("onload="))
                return "ONLOAD";
            if (payload.Contains("javascript:"))
                return "JAVASCRIPT_URL";

            // Authentication bypass patterns
            if (payload.Contains("' OR '1'='1"))
                return "AUTH_BYPASS_OR";
            if (payload.Contains("' OR 1=1--"))
                return "AUTH_BYPASS_1_1";
            if (payload.Contains("' OR 1=1#"))
                return "AUTH_BYPASS_HASH";

            // Path traversal patterns
            if (payload.Contains("../"))
                return "PATH_TRAVERSAL";
            if (payload.Contains("..\\"))
                return "PATH_TRAVERSAL_WIN";

            // Return first 50 characters as pattern for unknown payloads
            return payload.Length > 50 ? payload.Substring(0, 50) : payload;
        }

        /// <summary>
        /// Consolidates a group of similar vulnerabilities into a single vulnerability
        /// </summary>
        private Vulnerability ConsolidateVulnerabilityGroup(List<Vulnerability> group)
        {
            if (group.Count == 1)
                return group.First();

            var primaryVuln = group.First();
            var payloads = group.Select(v => v.Payload).Where(p => !string.IsNullOrEmpty(p)).Distinct().ToList();
            var evidences = group.Select(v => v.Evidence).Where(e => !string.IsNullOrEmpty(e)).Distinct().ToList();

            // Use the vulnerability with highest confidence as primary
            primaryVuln = group.OrderByDescending(v => v.Confidence).First();

            // Update title to indicate multiple payloads
            if (payloads.Count > 1)
            {
                primaryVuln.Title = $"{primaryVuln.Title} (Multiple Payloads)";
            }

            // Consolidate evidence
            if (evidences.Count > 1)
            {
                primaryVuln.Evidence = string.Join("; ", evidences.Take(3)); // Limit to first 3 evidences
                if (evidences.Count > 3)
                {
                    primaryVuln.Evidence += $" (and {evidences.Count - 3} more)";
                }
            }

            // Add payload count to description
            if (payloads.Count > 1)
            {
                primaryVuln.Description += $" This vulnerability was confirmed with {payloads.Count} different payloads.";
            }

            // Update confidence based on multiple confirmations
            if (group.Count > 1)
            {
                primaryVuln.Confidence = Math.Min(1.0, primaryVuln.Confidence + (group.Count - 1) * 0.1);
            }

            // Mark as verified if multiple payloads confirmed it
            if (group.Count >= 2)
            {
                primaryVuln.Verified = true;
            }

            return primaryVuln;
        }

        /// <summary>
        /// Removes low-confidence vulnerabilities that are likely false positives
        /// </summary>
        public List<Vulnerability> FilterFalsePositives(List<Vulnerability> vulnerabilities, double confidenceThreshold = 0.6)
        {
            _logger.Information("üîç Filtering false positives with confidence threshold: {Threshold}", confidenceThreshold);
            
            var filteredVulns = vulnerabilities.Where(v => v.Confidence >= confidenceThreshold).ToList();
            
            _logger.Information("üìä False positive filtering: {OriginalCount} ‚Üí {FilteredCount} vulnerabilities", 
                vulnerabilities.Count, filteredVulns.Count);
            _logger.Information("üìâ Removed: {RemovedCount} low-confidence findings", 
                vulnerabilities.Count - filteredVulns.Count);

            return filteredVulns;
        }

        /// <summary>
        /// Groups vulnerabilities by endpoint for better organization
        /// </summary>
        public Dictionary<string, List<Vulnerability>> GroupVulnerabilitiesByEndpoint(List<Vulnerability> vulnerabilities)
        {
            return vulnerabilities.GroupBy(v => $"{v.Method} {v.Endpoint}")
                .ToDictionary(g => g.Key, g => g.ToList());
        }

        /// <summary>
        /// Generates a summary of vulnerability distribution
        /// </summary>
        public VulnerabilityDistributionSummary GenerateDistributionSummary(List<Vulnerability> vulnerabilities)
        {
            var summary = new VulnerabilityDistributionSummary
            {
                TotalVulnerabilities = vulnerabilities.Count,
                UniqueEndpoints = vulnerabilities.Select(v => $"{v.Method} {v.Endpoint}").Distinct().Count(),
                VulnerabilityTypes = vulnerabilities.GroupBy(v => v.Type)
                    .ToDictionary(g => g.Key.ToString(), g => g.Count()),
                SeverityDistribution = vulnerabilities.GroupBy(v => v.Severity)
                    .ToDictionary(g => g.Key.ToString(), g => g.Count()),
                ConfidenceDistribution = new Dictionary<string, int>
                {
                    ["High (0.8-1.0)"] = vulnerabilities.Count(v => v.Confidence >= 0.8),
                    ["Medium (0.6-0.8)"] = vulnerabilities.Count(v => v.Confidence >= 0.6 && v.Confidence < 0.8),
                    ["Low (0.0-0.6)"] = vulnerabilities.Count(v => v.Confidence < 0.6)
                }
            };

            return summary;
        }
    }

    /// <summary>
    /// Summary of vulnerability distribution for reporting
    /// </summary>
    public class VulnerabilityDistributionSummary
    {
        public int TotalVulnerabilities { get; set; }
        public int UniqueEndpoints { get; set; }
        public Dictionary<string, int> VulnerabilityTypes { get; set; } = new();
        public Dictionary<string, int> SeverityDistribution { get; set; } = new();
        public Dictionary<string, int> ConfidenceDistribution { get; set; } = new();
    }
}
